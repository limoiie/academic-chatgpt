datasource db {
  provider = "sqlite"
  url      = "file:../../dev.db"
}

generator client {
  // Corresponds to the cargo alias created earlier
  provider = "cargo prisma"
  // The location to generate the client. Is relative to the position of the schema
  output   = "../src/core/db.rs"
}

model DocumentChunk {
  document  Document  @relation(fields: [documentId], references: [id])
  splitting Splitting @relation(fields: [splittingId], references: [id])
  no        Int
  content   String
  meta      String

  documentId  Int
  splittingId Int

  embeddings EmbeddingsOnDocumentChunks[]

  @@id([documentId, splittingId, no])
}

model Splitting {
  id           Int @id @default(autoincrement())
  chunkSize    Int
  chunkOverlap Int

  documents               SplittingsOnDocuments[]
  documentChunks          DocumentChunk[]
  collectionIndexProfiles CollectionIndexProfile[]

  @@unique([chunkOverlap, chunkSize])
}

model SplittingsOnDocuments {
  splitting Splitting @relation(fields: [splittingId], references: [id])
  document  Document  @relation(fields: [documentId], references: [id])

  splittingId Int
  documentId  Int

  @@id([splittingId, documentId])
}

model Document {
  id         Int      @id @default(autoincrement())
  filename   String
  filepath   String
  md5Hash    String
  updateTime DateTime

  collections    CollectionsOnDocuments[]
  splitings      SplittingsOnDocuments[]
  documentChunks DocumentChunk[]
}

model Collection {
  id   Int    @id @default(autoincrement())
  name String

  documents CollectionsOnDocuments[]
  profiles  CollectionIndexProfile[]
}

model CollectionsOnDocuments {
  collection Collection @relation(fields: [collectionId], references: [id])
  document   Document   @relation(fields: [documentId], references: [id])

  collectionId Int
  documentId   Int

  @@id([collectionId, documentId])
}

model EmbeddingsClient {
  id   Int    @id @default(autoincrement())
  name String
  type String
  info String

  @@unique([type, info])
}

model EmbeddingsConfig {
  id         Int    @id @default(autoincrement())
  name       String
  clientType String
  meta       String

  chunks                  EmbeddingsOnDocumentChunks[]
  collectionIndexProfiles CollectionIndexProfile[]
}

model EmbeddingsOnDocumentChunks {
  documentChunk    DocumentChunk    @relation(fields: [documentId, splittingId, documentChunkNo], references: [documentId, splittingId, no])
  embeddingsConfig EmbeddingsConfig @relation(fields: [embeddingsConfigId], references: [id])
  vector           Bytes

  documentId         Int
  splittingId        Int
  documentChunkNo    Int
  embeddingsConfigId Int

  @@id([documentId, splittingId, documentChunkNo, embeddingsConfigId])
}

model VectorDbConfig {
  id         Int    @id @default(autoincrement())
  name       String
  client     String
  clientInfo String
  meta       String

  collectionIndexProfiles CollectionIndexProfile[]
}

model CollectionIndexProfile {
  id               Int              @id @default(autoincrement())
  name             String
  collection       Collection       @relation(fields: [collectionId], references: [id])
  splitting        Splitting        @relation(fields: [splittingId], references: [id])
  embeddingsConfig EmbeddingsConfig @relation(fields: [embeddingsConfigId], references: [id])
  vectorDbConfig   VectorDbConfig   @relation(fields: [vectordbConfigId], references: [id])

  collectionId       Int
  splittingId        Int
  embeddingsConfigId Int
  vectordbConfigId   Int

  sessions Session[]

  @@unique([collectionId, name])
}

model Session {
  id                     Int                    @id @default(autoincrement())
  name                   String
  collectionIndexProfile CollectionIndexProfile @relation(fields: [collectionProfileId], references: [id])
  history                String

  collectionProfileId Int
}
